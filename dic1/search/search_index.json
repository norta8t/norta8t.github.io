{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"0. Herzlich Willkommen zu DIC1 Skript f\u00fcr die das Fach DIC1. Aufbau des Skriptes Das Skript wurde mit MkDocs erstellt und wird st\u00e4ndig erweitert. Letzte \u00c4nderung: 19.09.2024","title":"0. Herzlich Willkommen zu DIC1"},{"location":"#0-herzlich-willkommen-zu-dic1","text":"Skript f\u00fcr die das Fach DIC1.","title":"0. Herzlich Willkommen zu DIC1"},{"location":"#aufbau-des-skriptes","text":"Das Skript wurde mit MkDocs erstellt und wird st\u00e4ndig erweitert. Letzte \u00c4nderung: 19.09.2024","title":"Aufbau des Skriptes"},{"location":"1_digital/","text":"1. Digitale Elektronik 1.1 Aufbau von Digitalrechnern 1.1.1 Begriffe und Abk\u00fcrzungen Abk\u00fcrzung Bedeutung CPU C entral P rocessing U nit ADC A nalog D igital C onverter I/O I n/ O ut RAM R andom A ccess M emory ROM R ead O nly M emory Datenbus Ein Datenbus besteht aus einer oder mehreren Daten-Leitungen, \u00fcber welche Informationen zwischen verschiedenen Komponenten \u00fcbertragen werden. Ein Datenbus hat eine bestimmte Breite (z.B. 8bit, 16bit, ...). Beim AVR ist der Datenbus 8bit breit. Adressbus Der Adressbus besteht aus einer oder mehreren Adress-Leitungen, \u00fcber welche einzelne Speicheradressen (= Speicherort von Daten und/oder Befehlen) angesprochen werden k\u00f6nnen. Somit sind 2^n verschiedene Speicheradressen m\u00f6glich wobei n die Anzahl der Adress-Leitungen ist. Zum Beispiel k\u00f6nnen mit einem 16bit-Datenbus 65536 verschiedene Adressen angesprochen werden. Hinter einer Adresse k\u00f6nnen sich wiederum Daten in unterschiedlicher Breite befinden (8bit, 64bit, ...). Speicher Speicher wird zum Speichern von Daten und Programmcode verwendet. Grunds\u00e4tzlich wird unterschieden zwischen fl\u00fcchtigen (engl. volatile) und nicht-fl\u00fcchtigen (eng. non-volatile) Speicher. Fl\u00fcchtige Speicher verlieren ihren Speicherinhalt, sobald die Versorgungsspannung entfernt wird (Beispiel Hauptspeicher im Computer). Nicht-fl\u00fcchtiger Speicher beh\u00e4lt hingegen die Daten auch wenn keine Versorgungsspannung anliegt (Beispiel Festplatte im Computer). 1.1.2 Grundarchitekturen Es wird haupts\u00e4chlich zwischen zwei Grundarchitekturen unterschieden: Van-Neumann Architektur Diese Architektur, benannt nach dem Mathematiker John von Neumann, hat einen einzigen Speicher, der sowohl Daten als auch Programmcode speichert. Der Prozessor (CPU) l\u00e4dt Befehle und Daten aus demselben Speicher. Dies f\u00fchrt zu einer vereinfachten Implementierug, jedoch auch zu einem Flaschenhals: Befehle und Daten m\u00fcssen den gleichen Bus benutzen um zur CPU zu gelangen. Harvard-Architektur Diese Architektur trennt den Speicher in zwei getrennte Bereich, einen f\u00fcr Daten und einen f\u00fcr Befehle. Dadurch k\u00f6nnen Daten und Befehle gleichzeitig abgerufen werden - somit erh\u00f6ht sich die Verarbeitungsgeschwindigkeit. Varianten dieser Architektur finden sich h\u00e4ufig in modernen Mikrocontrollern und digitalen Signalprozessoren, so z.B. auch beim AVR. 1.1.1 Aufbau der CPU Die CPU als \"Gehirn\" besteht im Wesentlichen aus zwei Teilen: Steuerwerk (Control Unit, CU) Rechenwerk (Arithmetik Logic Unit, ALU)","title":"1. Digitale Elektronik"},{"location":"1_digital/#1-digitale-elektronik","text":"","title":"1. Digitale Elektronik"},{"location":"1_digital/#11-aufbau-von-digitalrechnern","text":"","title":"1.1 Aufbau von Digitalrechnern"},{"location":"1_digital/#111-begriffe-und-abkurzungen","text":"Abk\u00fcrzung Bedeutung CPU C entral P rocessing U nit ADC A nalog D igital C onverter I/O I n/ O ut RAM R andom A ccess M emory ROM R ead O nly M emory Datenbus Ein Datenbus besteht aus einer oder mehreren Daten-Leitungen, \u00fcber welche Informationen zwischen verschiedenen Komponenten \u00fcbertragen werden. Ein Datenbus hat eine bestimmte Breite (z.B. 8bit, 16bit, ...). Beim AVR ist der Datenbus 8bit breit. Adressbus Der Adressbus besteht aus einer oder mehreren Adress-Leitungen, \u00fcber welche einzelne Speicheradressen (= Speicherort von Daten und/oder Befehlen) angesprochen werden k\u00f6nnen. Somit sind 2^n verschiedene Speicheradressen m\u00f6glich wobei n die Anzahl der Adress-Leitungen ist. Zum Beispiel k\u00f6nnen mit einem 16bit-Datenbus 65536 verschiedene Adressen angesprochen werden. Hinter einer Adresse k\u00f6nnen sich wiederum Daten in unterschiedlicher Breite befinden (8bit, 64bit, ...). Speicher Speicher wird zum Speichern von Daten und Programmcode verwendet. Grunds\u00e4tzlich wird unterschieden zwischen fl\u00fcchtigen (engl. volatile) und nicht-fl\u00fcchtigen (eng. non-volatile) Speicher. Fl\u00fcchtige Speicher verlieren ihren Speicherinhalt, sobald die Versorgungsspannung entfernt wird (Beispiel Hauptspeicher im Computer). Nicht-fl\u00fcchtiger Speicher beh\u00e4lt hingegen die Daten auch wenn keine Versorgungsspannung anliegt (Beispiel Festplatte im Computer).","title":"1.1.1 Begriffe und Abk\u00fcrzungen"},{"location":"1_digital/#112-grundarchitekturen","text":"Es wird haupts\u00e4chlich zwischen zwei Grundarchitekturen unterschieden: Van-Neumann Architektur Diese Architektur, benannt nach dem Mathematiker John von Neumann, hat einen einzigen Speicher, der sowohl Daten als auch Programmcode speichert. Der Prozessor (CPU) l\u00e4dt Befehle und Daten aus demselben Speicher. Dies f\u00fchrt zu einer vereinfachten Implementierug, jedoch auch zu einem Flaschenhals: Befehle und Daten m\u00fcssen den gleichen Bus benutzen um zur CPU zu gelangen. Harvard-Architektur Diese Architektur trennt den Speicher in zwei getrennte Bereich, einen f\u00fcr Daten und einen f\u00fcr Befehle. Dadurch k\u00f6nnen Daten und Befehle gleichzeitig abgerufen werden - somit erh\u00f6ht sich die Verarbeitungsgeschwindigkeit. Varianten dieser Architektur finden sich h\u00e4ufig in modernen Mikrocontrollern und digitalen Signalprozessoren, so z.B. auch beim AVR.","title":"1.1.2 Grundarchitekturen"},{"location":"1_digital/#111-aufbau-der-cpu","text":"Die CPU als \"Gehirn\" besteht im Wesentlichen aus zwei Teilen: Steuerwerk (Control Unit, CU) Rechenwerk (Arithmetik Logic Unit, ALU)","title":"1.1.1 Aufbau der CPU"},{"location":"2_c/","text":"2. C-Programmierung 2.1 Allgemeines ... 2.2 Datentypen in AVR-GCC Datentypen sind \"Formal die Zusammenfassung von Objektmengen mit allen darauf definierten Operationen\" (Wikipedia). Standardisierte Datentypen werden seit C99 in der Header-Datei stdint.h zur Verf\u00fcgung gestellt. Diese Datei ist z.B. \u00fcber Dependencies in einem Projekt einsehbar. Aus dem Namen ist die Bitbreite erkennbar. Integertypen mit Vorzeichen Typename Wertebereich Alias (AVR-GCC) int8_t -128..127 signed char int16_t -32768..32767 signed int int32_t -2147483648..2147483647 signed long int int64_t -9223372036854775808..9223372036854775807 signed long long Integertypen ohne Vorzeichen Typename Wertebereich Alias (AVR-GCC) uint8_t 0..255 unsigned char uint16_t 0..65535 unsigned int uint32_t 0..4294967295 unsigned long int uint64_t 0..18446744073709551615 unsigned long long Weitere Datentypen Floats/Doubles werden im Kapitel Verschiedenes behandelt. char ... todo Es ist in C auch m\u00f6glich, eigen Datentypen zu definieren (typedef): #include <stido.h> #include <string.h> typedef struct Telefon { char hersteller[30]; char typ[20]; char telefonnummer[20]; } Telefon int main(){ Telefon telefon; strcpy(telefon.hersteller, \"Samsung\"); strcpy(telefon.typ, \"SM-30\"); strcpy(telefon.telefonnummer, \"+43 664 1234567); printf(\"Hersteller: %s\\n\", telefon.hersteller); return(0); } 2.10 Verschiedenes 2.10.1 Float-Unterst\u00fctzung in Microchip Studio Standardm\u00e4\u00dfig ist in Microchip Studio die Unterst\u00fctzung f\u00fcr floats ausgeschaltet. Eine Anleitung, wie die Unterst\u00fctzung f\u00fcr floats in Microchip-Studio eingeschaltet werden kann findet sich z.b. hier . NOTE: Durch die Aktivierung der Unterst\u00fctzung f\u00fcr floats, wird die compilierte Datei gr\u00f6\u00dfer. Wird mit float-Werten gerechnet, ist auf die Verwendung von Literals zu achten. So ergibt z.B. folgendes Beispiel... int i; i = 3 / 2; ... als Ergebnis 0. Werden hingegen Float Literals verwendet (hier 3.0 )... int i; i = 3.0 / 2; ... wird das korrekte Ergebnis 1.5 ausgegeben. Dabei spielt es keine Rolle, ob der erste Wert, der zweite Wert oder beide Werte als Literals angegeben sind (jedoch mindestens einer). \u00dcblicherweise sind in C float und double unterschiedlich definiert. float 32-bit double 64-bit NOTE: In Compiler von Microchip-Studio sind float und double gleich gro\u00df (32-bit). \u00dcberpr\u00fcfbar ist dies z.B. \u00fcber den Aufruf der Funktion sizeof(double) , welche dann die Anzahl an Bytes zur\u00fcckgibt. 2.10.2 Literals Literals in C sind Daten, welche direkt in den Quellcode eingef\u00fcgt werden k\u00f6nnen und deren Werte sich w\u00e4hrend der Laufzeit des Programms nicht \u00e4ndern. Beispiele sind: Bezeichnung Beispiel Integer Literals 123 (dezimal), 0x42 (hexadezimal), 077 (octal) Floating-point Literals 2.0 oder 145.2 Character Literals 'a', '\\n' String Literals \"Hello, World!\" Boolean Literals true, false 2.10.3 Pointer Zeiger (engl. Pointer) erm\u00f6glichen den direkten Zugriff auf die Speicheradressen von Daten. Sie sind im Wesentlichen eine Variable, deren Wert die Adresse einer anderen Variable ist. Dadurch kann ein Programm effizienter - sprich platzsparender - mit Speicherressourcen umgehen und es k\u00f6nnen dynamischen Datenstrukturen (wie z.B. Listen) implementiert werden. Beim AVR ist ein Pointer immer 16 bit breit und enth\u00e4lt zudem Informationen \u00fcber den Datentypen, auf den er zeigt.","title":"2. C-Programmierung"},{"location":"2_c/#2-c-programmierung","text":"","title":"2. C-Programmierung"},{"location":"2_c/#21-allgemeines","text":"...","title":"2.1 Allgemeines"},{"location":"2_c/#22-datentypen-in-avr-gcc","text":"Datentypen sind \"Formal die Zusammenfassung von Objektmengen mit allen darauf definierten Operationen\" (Wikipedia). Standardisierte Datentypen werden seit C99 in der Header-Datei stdint.h zur Verf\u00fcgung gestellt. Diese Datei ist z.B. \u00fcber Dependencies in einem Projekt einsehbar. Aus dem Namen ist die Bitbreite erkennbar. Integertypen mit Vorzeichen Typename Wertebereich Alias (AVR-GCC) int8_t -128..127 signed char int16_t -32768..32767 signed int int32_t -2147483648..2147483647 signed long int int64_t -9223372036854775808..9223372036854775807 signed long long Integertypen ohne Vorzeichen Typename Wertebereich Alias (AVR-GCC) uint8_t 0..255 unsigned char uint16_t 0..65535 unsigned int uint32_t 0..4294967295 unsigned long int uint64_t 0..18446744073709551615 unsigned long long Weitere Datentypen Floats/Doubles werden im Kapitel Verschiedenes behandelt. char ... todo Es ist in C auch m\u00f6glich, eigen Datentypen zu definieren (typedef): #include <stido.h> #include <string.h> typedef struct Telefon { char hersteller[30]; char typ[20]; char telefonnummer[20]; } Telefon int main(){ Telefon telefon; strcpy(telefon.hersteller, \"Samsung\"); strcpy(telefon.typ, \"SM-30\"); strcpy(telefon.telefonnummer, \"+43 664 1234567); printf(\"Hersteller: %s\\n\", telefon.hersteller); return(0); }","title":"2.2 Datentypen in AVR-GCC"},{"location":"2_c/#210-verschiedenes","text":"","title":"2.10 Verschiedenes"},{"location":"2_c/#2101-float-unterstutzung-in-microchip-studio","text":"Standardm\u00e4\u00dfig ist in Microchip Studio die Unterst\u00fctzung f\u00fcr floats ausgeschaltet. Eine Anleitung, wie die Unterst\u00fctzung f\u00fcr floats in Microchip-Studio eingeschaltet werden kann findet sich z.b. hier . NOTE: Durch die Aktivierung der Unterst\u00fctzung f\u00fcr floats, wird die compilierte Datei gr\u00f6\u00dfer. Wird mit float-Werten gerechnet, ist auf die Verwendung von Literals zu achten. So ergibt z.B. folgendes Beispiel... int i; i = 3 / 2; ... als Ergebnis 0. Werden hingegen Float Literals verwendet (hier 3.0 )... int i; i = 3.0 / 2; ... wird das korrekte Ergebnis 1.5 ausgegeben. Dabei spielt es keine Rolle, ob der erste Wert, der zweite Wert oder beide Werte als Literals angegeben sind (jedoch mindestens einer). \u00dcblicherweise sind in C float und double unterschiedlich definiert. float 32-bit double 64-bit NOTE: In Compiler von Microchip-Studio sind float und double gleich gro\u00df (32-bit). \u00dcberpr\u00fcfbar ist dies z.B. \u00fcber den Aufruf der Funktion sizeof(double) , welche dann die Anzahl an Bytes zur\u00fcckgibt.","title":"2.10.1 Float-Unterst\u00fctzung in Microchip Studio"},{"location":"2_c/#2102-literals","text":"Literals in C sind Daten, welche direkt in den Quellcode eingef\u00fcgt werden k\u00f6nnen und deren Werte sich w\u00e4hrend der Laufzeit des Programms nicht \u00e4ndern. Beispiele sind: Bezeichnung Beispiel Integer Literals 123 (dezimal), 0x42 (hexadezimal), 077 (octal) Floating-point Literals 2.0 oder 145.2 Character Literals 'a', '\\n' String Literals \"Hello, World!\" Boolean Literals true, false","title":"2.10.2 Literals"},{"location":"2_c/#2103-pointer","text":"Zeiger (engl. Pointer) erm\u00f6glichen den direkten Zugriff auf die Speicheradressen von Daten. Sie sind im Wesentlichen eine Variable, deren Wert die Adresse einer anderen Variable ist. Dadurch kann ein Programm effizienter - sprich platzsparender - mit Speicherressourcen umgehen und es k\u00f6nnen dynamischen Datenstrukturen (wie z.B. Listen) implementiert werden. Beim AVR ist ein Pointer immer 16 bit breit und enth\u00e4lt zudem Informationen \u00fcber den Datentypen, auf den er zeigt.","title":"2.10.3 Pointer"},{"location":"3_timer/","text":"3. Timer In diesem Abschnitt werden die Grundlagen zu Timer0, Timer1 und Timer2 behandelt. Eine tiefergehende Einf\u00fchrung findet dabei im Wahlfach statt. 3.1 Allgemeines 3.2 Timer0 3.2.1 CTC Mode (Clear Timer on Compare) Der CTC Mode kann verwendet werden um ein Rechtecksignal zu erzeugen. Dies wird erreicht, indem ein Ausgang beim Erreichen des OCR-Wertes getoggelt wird (entweder manuell oder \u00fcber den Compare Output toggle mode). Dabei berechnet sich die Frequenz mit der folgenden Formel: N ... Prescaler Wert 3.3 Timer1 3.3.1 Unterschiede zu Timer0 3.3.2 ICP Mode Port D, Bit 6 hat als alternative Funktion ICP1 (Input Capture Pin f\u00fcr Timer 1). Das Input Capture Register (ICR1) kann den Timer/Counter Wert zu einem externen (flankengetriggerten) Ereignis speichern. 3.3.3.1 Beispiel Im folgenden Beispiel wird mit Timer 0 ein Signal erzeugt, welches am Ausgang PB0 ausgegeben wird. Dieses Signal wird mit PD6 verbunden, wo mit Timer 1 die Periodendauer/Frequenz des Signals bestimmt wird und auf dem Display ausgegeben wird. Code Stand: 13.03.2024 Die Periodendauer/Frequenz wird dabei mit folgenden Formeln bestimmt: 3.3.3 Allgemeines zur Zeitmessung Im bisherigen Beispiel haben wir nur betrachtet, wie die Zeit zwischen zwei (steigenden) Flanken berechnet werden kann. Dabei war zu beachten, dass der Z\u00e4hler nicht \u00fcberl\u00e4uft, sprich die Periodendauer nicht l\u00e4nger ist als 2^16 Taktzyklen (Timer1). F\u00fcr z.B. die Implementierung einer Stopuhr ist dies nicht ausreichend. Im folgenden werden allgemeine Hinweise gegeben, was bei einer Zeitmessung/Stoppuhr beachtet werden muss. Problem 1: \u00dcberlauf des Z\u00e4hlers Der maximale Z\u00e4hlerwert ist begrenzt durch die Bitbreite des verwendeten Timers (8 bzw. 16 bit). Als allgemeine Formel zum berechnen der Anzahl der ticks zwischen START und STOP kann verwendet werden: Problem 2: Zwischenzeit Der Timer kann f\u00fcr die Messung der Zwischenzeit nicht angehalten werden da dies eine Fehlzeit ergeben w\u00fcrde. Als L\u00f6sung k\u00f6nnen Schattenregister verwendet werden (Double Buffered Register). Weitergehende Informationen finden sich z.B. hier Problem 3: Datentypen F\u00fcr die Speicherung von langen Zeitmessugen m\u00fcssen Datentypen mit gro\u00dfen Wertebereichen gew\u00e4hlt werden, z.B. uint32_t oder uint64_t. Siehe auch Kapittel Datentypen im Modul C-Programmierung. 3.4 Timer 2 Timer2 hat im Wesentlichen die gleichen Modi wie Timer0 und ist ebenfalls ein 8-bit Timer/Counter und leichte Abweichungen (z.B. andere Prescaler) Wie bei Timer1 (ICP Mode, insbesondere f\u00fcr Zeitmessung) wird im folgenden f\u00fcr Timer2 nur auf eine Besonderheit eingegangen: die M\u00f6glichkeit einen Real Time Counter/Clock (RTC) zu implementieren. Bei setzen des Bits AS2 im ASSR Register, wird Timer2/Counter2 asynchron vom Eingang TOSC1 getaktet. Dabei wird ein Quarz twischen den Pins TOSC1 und TOSC2 angeschlossen. Der interne Oszillator ist dabei optimiert f\u00fcr die Verwendung eines 32.768 kHz Quarzes. Diese Quarze sind typisch f\u00fcr Uhrenanwendungen da: G\u00fcnstig herzustellen Niedrigerer Stromverbrauch (wg. niedriger Frequenz) Teilbar um z.B. 1Hz Signal zu erzeugen So ergibt z.B. ein Prescaler von 128 bei einem 8-bit Z\u00e4hler einen Z\u00e4hler\u00fcberlauf jede Sekunde. Details finden sich im Datenblatt im Abschnitt Asyncrhonous Operation of the Timer/Counter2. Die folgende Application Note AVR Application Note 134 beschreibt, wie man eine RTC f\u00fcr einen AVR implementieren kann.","title":"3. Timer"},{"location":"3_timer/#3-timer","text":"In diesem Abschnitt werden die Grundlagen zu Timer0, Timer1 und Timer2 behandelt. Eine tiefergehende Einf\u00fchrung findet dabei im Wahlfach statt.","title":"3. Timer"},{"location":"3_timer/#31-allgemeines","text":"","title":"3.1 Allgemeines"},{"location":"3_timer/#32-timer0","text":"","title":"3.2 Timer0"},{"location":"3_timer/#321-ctc-mode-clear-timer-on-compare","text":"Der CTC Mode kann verwendet werden um ein Rechtecksignal zu erzeugen. Dies wird erreicht, indem ein Ausgang beim Erreichen des OCR-Wertes getoggelt wird (entweder manuell oder \u00fcber den Compare Output toggle mode). Dabei berechnet sich die Frequenz mit der folgenden Formel: N ... Prescaler Wert","title":"3.2.1 CTC Mode (Clear Timer on Compare)"},{"location":"3_timer/#33-timer1","text":"","title":"3.3 Timer1"},{"location":"3_timer/#331-unterschiede-zu-timer0","text":"","title":"3.3.1 Unterschiede zu Timer0"},{"location":"3_timer/#332-icp-mode","text":"Port D, Bit 6 hat als alternative Funktion ICP1 (Input Capture Pin f\u00fcr Timer 1). Das Input Capture Register (ICR1) kann den Timer/Counter Wert zu einem externen (flankengetriggerten) Ereignis speichern.","title":"3.3.2 ICP Mode"},{"location":"3_timer/#3331-beispiel","text":"Im folgenden Beispiel wird mit Timer 0 ein Signal erzeugt, welches am Ausgang PB0 ausgegeben wird. Dieses Signal wird mit PD6 verbunden, wo mit Timer 1 die Periodendauer/Frequenz des Signals bestimmt wird und auf dem Display ausgegeben wird. Code Stand: 13.03.2024 Die Periodendauer/Frequenz wird dabei mit folgenden Formeln bestimmt:","title":"3.3.3.1 Beispiel"},{"location":"3_timer/#333-allgemeines-zur-zeitmessung","text":"Im bisherigen Beispiel haben wir nur betrachtet, wie die Zeit zwischen zwei (steigenden) Flanken berechnet werden kann. Dabei war zu beachten, dass der Z\u00e4hler nicht \u00fcberl\u00e4uft, sprich die Periodendauer nicht l\u00e4nger ist als 2^16 Taktzyklen (Timer1). F\u00fcr z.B. die Implementierung einer Stopuhr ist dies nicht ausreichend. Im folgenden werden allgemeine Hinweise gegeben, was bei einer Zeitmessung/Stoppuhr beachtet werden muss. Problem 1: \u00dcberlauf des Z\u00e4hlers Der maximale Z\u00e4hlerwert ist begrenzt durch die Bitbreite des verwendeten Timers (8 bzw. 16 bit). Als allgemeine Formel zum berechnen der Anzahl der ticks zwischen START und STOP kann verwendet werden: Problem 2: Zwischenzeit Der Timer kann f\u00fcr die Messung der Zwischenzeit nicht angehalten werden da dies eine Fehlzeit ergeben w\u00fcrde. Als L\u00f6sung k\u00f6nnen Schattenregister verwendet werden (Double Buffered Register). Weitergehende Informationen finden sich z.B. hier Problem 3: Datentypen F\u00fcr die Speicherung von langen Zeitmessugen m\u00fcssen Datentypen mit gro\u00dfen Wertebereichen gew\u00e4hlt werden, z.B. uint32_t oder uint64_t. Siehe auch Kapittel Datentypen im Modul C-Programmierung.","title":"3.3.3 Allgemeines zur Zeitmessung"},{"location":"3_timer/#34-timer-2","text":"Timer2 hat im Wesentlichen die gleichen Modi wie Timer0 und ist ebenfalls ein 8-bit Timer/Counter und leichte Abweichungen (z.B. andere Prescaler) Wie bei Timer1 (ICP Mode, insbesondere f\u00fcr Zeitmessung) wird im folgenden f\u00fcr Timer2 nur auf eine Besonderheit eingegangen: die M\u00f6glichkeit einen Real Time Counter/Clock (RTC) zu implementieren. Bei setzen des Bits AS2 im ASSR Register, wird Timer2/Counter2 asynchron vom Eingang TOSC1 getaktet. Dabei wird ein Quarz twischen den Pins TOSC1 und TOSC2 angeschlossen. Der interne Oszillator ist dabei optimiert f\u00fcr die Verwendung eines 32.768 kHz Quarzes. Diese Quarze sind typisch f\u00fcr Uhrenanwendungen da: G\u00fcnstig herzustellen Niedrigerer Stromverbrauch (wg. niedriger Frequenz) Teilbar um z.B. 1Hz Signal zu erzeugen So ergibt z.B. ein Prescaler von 128 bei einem 8-bit Z\u00e4hler einen Z\u00e4hler\u00fcberlauf jede Sekunde. Details finden sich im Datenblatt im Abschnitt Asyncrhonous Operation of the Timer/Counter2. Die folgende Application Note AVR Application Note 134 beschreibt, wie man eine RTC f\u00fcr einen AVR implementieren kann.","title":"3.4 Timer 2"},{"location":"4_switches/","text":"4. Schalter / Pegelwandlung Dieses Kapitel behandelt folgende Themen: BJT (Schalter) MOS-FETs (Schalter) Pegelwandler CMOS-Inverter Der maximale Strom eine IO-Pins des ATmega16 ist gem\u00e4\u00df Datenblatt 40 mA . Um einen zuverl\u00e4ssigen Betrieb zu gew\u00e4hrleisten macht es in der Praxis Sinn, den maximalen Strom deutlich zu senken. Empfohlen werden max. 20mA. Werden nun Verbraucher mit deutlich h\u00f6heren Str\u00f6men durch den Mikrocontroller geschaltet (z.B. Lampen, Relais oder Motoren), ist eine zus\u00e4tzliche Schaltung notwendig. Im folgenden betrachten wir zwei M\u00f6glichkeiten - die Verwendung von bipolaren Transistoren sowie von Feldeffekt-Transistoren als Schalter. 4.1 BJT als Schalter 4.1.1 Allgemeines Ein Transistor eignet sich zum kontaktlosen Schalten kleiner und mittlerer Leisungen. Meist geschieht dies mit einem bipolaren Transistor vom Typ NPN (Emitterschaltung). Im folgenden wird ein typisches Ausgangskennlinienfeld eines npn-Transistors dargestellt: [Quelle] M\u00f6gliche Betriebsmodi eines Transistors sind: Sperrbereich (Cutoff Region) Betrieb als Schalter (OFF, ge\u00f6ffnet). Der Basisstrom IB ist 0, es flie\u00dft kein Kollektorstrom, die VCE entspricht VCC. Der Transistor arbeitet als offener Schalter. Aktiver Bereich (Linear/Active Region) Werden mit einem Transistor analoge Wechselsignale verst\u00e4rkt, wird dieser im linearen Bereich der Ausgangskennlinie betrieben. Dabei ist der Kollektorstrom proportional zum Basisstrom, analoge Signale werden mit minimaler Verzerrung verst\u00e4rkt. S\u00e4ttigungsbereich (Saturation Region) Betrieb als Schalter (ON, geschlossen). Es liegt ein ausreichend gro\u00dfer Basistrom (IB) an, um den Transistor vollst\u00e4ndig einzuschalten. Es flie\u00dft der maximale Kollektorstrom (Ic ~ Vcc/RL), die Kollektor-Emitter-Spannung ist minimal. Anmerkung: Der Transistor ist genaugenommen nie ganz sperrend oder ganz leitend, vielmehr kann der Widerstand der CE-Strecke sehr hochomig oder sehr niederohmig sein. 4.1.2 Dimensionierung Zu beachten ist weiters die maximal zul\u00e4ssige Kollektor-Emitter-Spannung sowie Ptot (total power) und ggfs. Schaltzeiten. Beispiel 4.1 Ein Transistor, angesteuert von einem ATmega16 (5V) soll eine Last schalten, welche 200 mA Strom ben\u00f6tigt. Was ist der Wert des Basiswiderstand (VBE = 0.7V, BETA=200) im ges\u00e4ttigten Zustand? 4.1.3 Arbeitspunktverschiebung Besonderheiten unterschiedlicher Lasten Arbeitspunktverschiebung Beim Schalten zwischen \"EIN\" und \"AUS\" durquert der Arbeitspunkt den verbotenen Bereich Ptot (maximale Leistung, die der Transistor sicher durch W\u00e4rme ableiten kann, ohne besch\u00e4digt zu werden - \u00dcberschreiten f\u00fchrt zu \u00dcberhitzung und m\u00f6glicherweise zur Zerst\u00f6rung des Transistors). Eine kurze \u00dcberschreitung ist unkritisch. Schalten ohmscher Last (z.B. Widerstand) Ohmsche Lasten sind unkritisch zu Schalten. Schalten einer kapazitiven Last (z.B. Kondensator) Eine kapazitive Last zieht beim Einschalten einen hohen Strom, der begrenzt werden muss. Schalten einer induktiven Last (z.B. Spule, Relais oder Motor) Beim Ausschalten einer induktiven Last wird eine Spannung induziert. Diese kann den Transistor zerst\u00f6ren. [Quelle Grafiken] Eine Freilaufdiode sch\u00fctzt den Transistor, indem sie einen Pfad zu VCC bildet. 4.1.5 Darlington-Transistorschalter Beispiel 4.2 Eine 3A-Last soll mit einem BD139 geschaltet werden. Die minimale Verst\u00e4rkung betr\u00e4gt 40. Was ist der IB? Kann IB von einem IO-Pin des ATmega16 geliefert werden? Wie verh\u00e4lt es sich mit einem TIP120 ? Was ist der RB? Darlington-Transistoren sind Kombinationen aus zwei Bipolartransistoren. Sie weisen eine sehr hohe Stromverst\u00e4rkung, sind also ideal geeignet in Anwendungsf\u00e4llen wo hohe Str\u00f6me geschaltet werden m\u00fcssen und nur ein geringer Steuerstrom zur Verf\u00fcgung steht. Hauptmerkmale sind die hohe Verst\u00e4rkung (= gew\u00fcnscht) und die relative hohe S\u00e4ttigungsspannung (= unerw\u00fcnscht). 4.2 FETs 4.2.1 Allgemeines Im Vergleich zum bipolaren Transistor haben Feldeffekt-Transistoren den gro\u00dfen Vorteil, dass das Gate keinen Strom zieht (sehr hohe Eigangsimpendanz). Die Steuerung erfolgt mit Spannung, nicht mit Strom. Unterschieden werden: JFET = engl. J unction F ield E ffect Transistor, \u00dcbergangszonen FET, der steuerbare Kanal wird durch einen PN-\u00dcbergang wie in einer Diode gebildet MOSFET = engl. M etall O xide S emiconductor F ield E ffect T ransistor; Metalloxidschicht-FET, gr\u00f6\u00dfte Teilgruppe der FETs mit isoliertem Gate [Quelle Grafik] [Quelle Grafik] 4.2.2 Anwendungsf\u00e4lle (FET als Schalter) Digitalelektronik Multiplexer Schaltwandler On/Off Batterie Ver\u00e4nderbare Filter Sample-and-hold Schaltung Digitale Potentiometer H-Br\u00fccke Zur Schaltung von DC-Elektromotoren (vorw\u00e4rts/r\u00fcckw\u00e4rts) - kann diskret aufgebaut werden oder mit dedizierten ICs. 4.2.3 Auswahl eines N-Kanal-MOSFET f\u00fcr Logikpegel Folgende Parameter sind bei der initialen Auswahl eines N-Knal-MOSFET f\u00fcr Logikpegel zu ber\u00fccksichtigen: Drain-Strom ID Der maximale Dauerstrom (oder ggfs. der maximale Pulsstrom) ist abh\u00e4ngig von der zu schaltenden Last Gate-Source-Schwellenspannung Vgs(th)(min) und Vgs(th)(max) Die Gate-Source Schwellspannung (Gate-Source Threshold Voltage) gibt an, ab welcher Spannung der MOSFET anf\u00e4ngt, minimal leitf\u00e4hig zu werden. Technologisch bedingt ist diese Spannung einer starken Toleranz unterworfen (typische Spreizung von 1:2 zwischen Miminum und Maximum). Un den gew\u00fcnschten Rds(on) zu erreichen, muss die Vgs ggfs. h\u00f6her sein (siehe Datenblatt). Drain-Source-Durchlasswiderstand - Rds(on) Eingangskapazit\u00e4t - Ciss Die Eingangskapazit\u00e4t sollte m\u00f6glichst gering sein, insbesondere bei hohen Schaltfrequenzen. Beispiel 4.3 Suchen Sie auf digikey.at einen MOSFET \u00fcber die Parametersuche, welche von einem ATmega16 angesteuert werden kann und eine Last von 3A schalten kann. Was ist Rds(on) des MOSFET? Was ist die Gate-Source-Schwellenspannung (Bereich)? Was ist die Eingangskapazit\u00e4t Ciss? Beispiel 4.4 LTSpice Simulation mit dem MOSFET Si7336ADP Beispiel 4.5 Simulieren Sie in LTSpice selbstst\u00e4ndig folgende Aufgaben zum BSP89 : Als Basis f\u00fcr die Aufgabe dient diese Schaltung: Aufgabe 1 : DC sweep von Vgs von 0-20V. Bei welcher Schwellspannung beginnt der MOSFET zu schalten? Was ist der Gate-Strom? Aufgabe 2 : Wieviel ist der Verlauf der Leistung bei Aufgabe 1? (Hinweis: ALT + linke Maustaste) Aufgabe 3 : Bestimmen von Rds(on) im voll durchgeschalteten Betrieb. Wieviel Ohm sind es? Passt der Wert zum Datenblatt? (Hinweis: Rds(on)=Vds/Id Aufgabe 4 : Zeichnen des Kennlinienfelds des MOSFET (Hinweis: Sweep Vds von 0-240V, Vgs von 0-20V in 4V Schritten). Warum wurden diese Werte gew\u00e4hlt? Wo befindet sich der lineare Bereich? Wo der S\u00e4ttigungsbereich? Wo der Sperrbereich? Aufgabe 5 : MOSFET Steuerspannung (Vgs) gepulst (100Hz). Wieviel Strom zieht das Gate aufgrund der^ Eingangskapazit\u00e4t Ciss beim Schalten? Kann ein ATmega16 diesen Strom liefern? Aufgabe 6: Linear-Betrieb (Verst\u00e4rker) - tbd 4.2.4 Anschluss an einen Mikrocontroller Sowohl JFETs als auch MOSFETs haben eine Eingangskapazit\u00e4t (Gate-Kapazit\u00e4t). Diese ist insbesondere beim MOSFET gr\u00f6\u00dfer und resultiert aus der Oxidschicht zwischen dem Gate und dem Kanal. Die hier auftretenden Einschaltstr\u00f6me k\u00f6nnen den IO-Pin eines Mikrocontrollers \u00fcberlasten - dies kann mit der folgenden Schaltung vermieden werden: Der Pull-down Widerstand sorgt dabei f\u00fcr einen definierten Pegel w\u00e4hrend des Starts und Resets des Mikrocontrollers. Anzumerken ist, dass der MOSFET f\u00fcr Logic Level (LL) ausgelegt ist, der schon bei einer Gatespannung von etwa 4.5V voll durchgesteuert sind. Die meisten FET werden mit ca. 10-15V angesteuert, wof\u00fcr wiederum eine eigene Treiberschaltung notwendig ist. 4.3 CMOS-Inverter Wird noch erg\u00e4nzt. 4.3 Pegelwandler \" Als Pegelumsetzer oder Pegelwandler (englisch level shifter) bezeichnet man in der Elektronik eine diskrete oder integrierte elektronische Schaltung, welche die Signalpegel \u2013 in der Regel Spannungssignale \u2013 einer Informationsquelle an die Eingangssignalpegel einer Informationssenke anpasst. Pegelumsetzer k\u00f6nnen sowohl in der Analogtechnik als auch in der Digitaltechnik angewendet werden. \" (Wikipedia) Es gibt verschiedenen M\u00f6glichkeiten, einen Pegelwandler umzusetzen. Einiger dieser Methoden sind im folgenden beschrieben: 4.3.1 Spannungsteiler Eine einfache und g\u00fcnstige Methode ist ein simpler Spannungsteiler. Dabei berechnet sich die Spannung aus: Bei Verwendung von Widerst\u00e4nden aus der E24-Reihe kann z.B. aus 5V mit einem R1 = 1.8k\u03a9 und R2 = 3.3k\u03a9 eine Ausgangsspannung von 3.3V erzeugt werden. Vorteile Einfach (geeignet f\u00fcr Prototyping) G\u00fcnstig Nachteile Unidirektional Nur von h\u00f6herer zu niedriger Spannung Ungeeignet f\u00fcr hohe Frequenzen 4.3.2 Diode \u00c4hnlich einfach ist die Verwendung einer Diode in Verbindung mit einem Widerstand (kann z.B. bei einem Mikrocontroller der interne Pull-up Widerstand am Eingang sein). Liegen an TX 5V an, sperrt die Diode und an RX liegt die Spannung \u00fcber den Pull-up Widerstand an (3V). Ist TX bei 0V, leitet die Diode und an RX liegt 0V + If an (If = Durchlassspannung). [Quelle] Vorteile Einfach (geeignet f\u00fcr Prototyping) G\u00fcnstig Nachteile Unidirektional Nur von h\u00f6herer zu niedriger Spannung Ungeeignet f\u00fcr hohe Frequenzen 4.3.3 MOSFET (N-Kanal) Mit einem MOSFET ist eine bidirektionale Anpassung des Spannungspegel m\u00f6glich. Die genaue Funktion ist hier erkl\u00e4rt. Vorteile Bidirektional Zuverl\u00e4ssig und schnell Nachteile Komplexer Setzt eine geeignete Auswahl des MOSFET voraus 4.3.4 Logic Level Converters Es gibt eine Vielzahl an dedizierten Schaltkreisen genau f\u00fcr diesen Zweck. Beispiel TXB0108 (8-Bit, bidirektional) Vorteile Bidirektional Zuverl\u00e4ssig und schnell Nachteile Teurer 4.3.5 Optokoppler Optokoppler isolieren zwei Schaltkreise elektrisch voneinander, indem er elektrische Signale mittels Licht \u00fcbertr\u00e4gt. Dies geschieht z.B. durch Verwendung einer LED und eines lichtempfindlichen Bauteils (z.B. Fotodiode). Vorteile Elektrische Isolation Zuverl\u00e4ssig Nachteile Langsamer","title":"4. Schalter / Pegelwandlung"},{"location":"4_switches/#4-schalter-pegelwandlung","text":"Dieses Kapitel behandelt folgende Themen: BJT (Schalter) MOS-FETs (Schalter) Pegelwandler CMOS-Inverter Der maximale Strom eine IO-Pins des ATmega16 ist gem\u00e4\u00df Datenblatt 40 mA . Um einen zuverl\u00e4ssigen Betrieb zu gew\u00e4hrleisten macht es in der Praxis Sinn, den maximalen Strom deutlich zu senken. Empfohlen werden max. 20mA. Werden nun Verbraucher mit deutlich h\u00f6heren Str\u00f6men durch den Mikrocontroller geschaltet (z.B. Lampen, Relais oder Motoren), ist eine zus\u00e4tzliche Schaltung notwendig. Im folgenden betrachten wir zwei M\u00f6glichkeiten - die Verwendung von bipolaren Transistoren sowie von Feldeffekt-Transistoren als Schalter.","title":"4. Schalter / Pegelwandlung"},{"location":"4_switches/#41-bjt-als-schalter","text":"","title":"4.1 BJT als Schalter"},{"location":"4_switches/#411-allgemeines","text":"Ein Transistor eignet sich zum kontaktlosen Schalten kleiner und mittlerer Leisungen. Meist geschieht dies mit einem bipolaren Transistor vom Typ NPN (Emitterschaltung). Im folgenden wird ein typisches Ausgangskennlinienfeld eines npn-Transistors dargestellt: [Quelle] M\u00f6gliche Betriebsmodi eines Transistors sind: Sperrbereich (Cutoff Region) Betrieb als Schalter (OFF, ge\u00f6ffnet). Der Basisstrom IB ist 0, es flie\u00dft kein Kollektorstrom, die VCE entspricht VCC. Der Transistor arbeitet als offener Schalter. Aktiver Bereich (Linear/Active Region) Werden mit einem Transistor analoge Wechselsignale verst\u00e4rkt, wird dieser im linearen Bereich der Ausgangskennlinie betrieben. Dabei ist der Kollektorstrom proportional zum Basisstrom, analoge Signale werden mit minimaler Verzerrung verst\u00e4rkt. S\u00e4ttigungsbereich (Saturation Region) Betrieb als Schalter (ON, geschlossen). Es liegt ein ausreichend gro\u00dfer Basistrom (IB) an, um den Transistor vollst\u00e4ndig einzuschalten. Es flie\u00dft der maximale Kollektorstrom (Ic ~ Vcc/RL), die Kollektor-Emitter-Spannung ist minimal. Anmerkung: Der Transistor ist genaugenommen nie ganz sperrend oder ganz leitend, vielmehr kann der Widerstand der CE-Strecke sehr hochomig oder sehr niederohmig sein.","title":"4.1.1 Allgemeines"},{"location":"4_switches/#412-dimensionierung","text":"Zu beachten ist weiters die maximal zul\u00e4ssige Kollektor-Emitter-Spannung sowie Ptot (total power) und ggfs. Schaltzeiten. Beispiel 4.1 Ein Transistor, angesteuert von einem ATmega16 (5V) soll eine Last schalten, welche 200 mA Strom ben\u00f6tigt. Was ist der Wert des Basiswiderstand (VBE = 0.7V, BETA=200) im ges\u00e4ttigten Zustand?","title":"4.1.2 Dimensionierung"},{"location":"4_switches/#413-arbeitspunktverschiebung-besonderheiten-unterschiedlicher-lasten","text":"Arbeitspunktverschiebung Beim Schalten zwischen \"EIN\" und \"AUS\" durquert der Arbeitspunkt den verbotenen Bereich Ptot (maximale Leistung, die der Transistor sicher durch W\u00e4rme ableiten kann, ohne besch\u00e4digt zu werden - \u00dcberschreiten f\u00fchrt zu \u00dcberhitzung und m\u00f6glicherweise zur Zerst\u00f6rung des Transistors). Eine kurze \u00dcberschreitung ist unkritisch. Schalten ohmscher Last (z.B. Widerstand) Ohmsche Lasten sind unkritisch zu Schalten. Schalten einer kapazitiven Last (z.B. Kondensator) Eine kapazitive Last zieht beim Einschalten einen hohen Strom, der begrenzt werden muss. Schalten einer induktiven Last (z.B. Spule, Relais oder Motor) Beim Ausschalten einer induktiven Last wird eine Spannung induziert. Diese kann den Transistor zerst\u00f6ren. [Quelle Grafiken] Eine Freilaufdiode sch\u00fctzt den Transistor, indem sie einen Pfad zu VCC bildet.","title":"4.1.3 Arbeitspunktverschiebung Besonderheiten unterschiedlicher Lasten"},{"location":"4_switches/#415-darlington-transistorschalter","text":"Beispiel 4.2 Eine 3A-Last soll mit einem BD139 geschaltet werden. Die minimale Verst\u00e4rkung betr\u00e4gt 40. Was ist der IB? Kann IB von einem IO-Pin des ATmega16 geliefert werden? Wie verh\u00e4lt es sich mit einem TIP120 ? Was ist der RB? Darlington-Transistoren sind Kombinationen aus zwei Bipolartransistoren. Sie weisen eine sehr hohe Stromverst\u00e4rkung, sind also ideal geeignet in Anwendungsf\u00e4llen wo hohe Str\u00f6me geschaltet werden m\u00fcssen und nur ein geringer Steuerstrom zur Verf\u00fcgung steht. Hauptmerkmale sind die hohe Verst\u00e4rkung (= gew\u00fcnscht) und die relative hohe S\u00e4ttigungsspannung (= unerw\u00fcnscht).","title":"4.1.5 Darlington-Transistorschalter"},{"location":"4_switches/#42-fets","text":"","title":"4.2 FETs"},{"location":"4_switches/#421-allgemeines","text":"Im Vergleich zum bipolaren Transistor haben Feldeffekt-Transistoren den gro\u00dfen Vorteil, dass das Gate keinen Strom zieht (sehr hohe Eigangsimpendanz). Die Steuerung erfolgt mit Spannung, nicht mit Strom. Unterschieden werden: JFET = engl. J unction F ield E ffect Transistor, \u00dcbergangszonen FET, der steuerbare Kanal wird durch einen PN-\u00dcbergang wie in einer Diode gebildet MOSFET = engl. M etall O xide S emiconductor F ield E ffect T ransistor; Metalloxidschicht-FET, gr\u00f6\u00dfte Teilgruppe der FETs mit isoliertem Gate [Quelle Grafik] [Quelle Grafik]","title":"4.2.1 Allgemeines"},{"location":"4_switches/#422-anwendungsfalle-fet-als-schalter","text":"Digitalelektronik Multiplexer Schaltwandler On/Off Batterie Ver\u00e4nderbare Filter Sample-and-hold Schaltung Digitale Potentiometer H-Br\u00fccke Zur Schaltung von DC-Elektromotoren (vorw\u00e4rts/r\u00fcckw\u00e4rts) - kann diskret aufgebaut werden oder mit dedizierten ICs.","title":"4.2.2 Anwendungsf\u00e4lle (FET als Schalter)"},{"location":"4_switches/#423-auswahl-eines-n-kanal-mosfet-fur-logikpegel","text":"Folgende Parameter sind bei der initialen Auswahl eines N-Knal-MOSFET f\u00fcr Logikpegel zu ber\u00fccksichtigen: Drain-Strom ID Der maximale Dauerstrom (oder ggfs. der maximale Pulsstrom) ist abh\u00e4ngig von der zu schaltenden Last Gate-Source-Schwellenspannung Vgs(th)(min) und Vgs(th)(max) Die Gate-Source Schwellspannung (Gate-Source Threshold Voltage) gibt an, ab welcher Spannung der MOSFET anf\u00e4ngt, minimal leitf\u00e4hig zu werden. Technologisch bedingt ist diese Spannung einer starken Toleranz unterworfen (typische Spreizung von 1:2 zwischen Miminum und Maximum). Un den gew\u00fcnschten Rds(on) zu erreichen, muss die Vgs ggfs. h\u00f6her sein (siehe Datenblatt). Drain-Source-Durchlasswiderstand - Rds(on) Eingangskapazit\u00e4t - Ciss Die Eingangskapazit\u00e4t sollte m\u00f6glichst gering sein, insbesondere bei hohen Schaltfrequenzen. Beispiel 4.3 Suchen Sie auf digikey.at einen MOSFET \u00fcber die Parametersuche, welche von einem ATmega16 angesteuert werden kann und eine Last von 3A schalten kann. Was ist Rds(on) des MOSFET? Was ist die Gate-Source-Schwellenspannung (Bereich)? Was ist die Eingangskapazit\u00e4t Ciss? Beispiel 4.4 LTSpice Simulation mit dem MOSFET Si7336ADP Beispiel 4.5 Simulieren Sie in LTSpice selbstst\u00e4ndig folgende Aufgaben zum BSP89 : Als Basis f\u00fcr die Aufgabe dient diese Schaltung: Aufgabe 1 : DC sweep von Vgs von 0-20V. Bei welcher Schwellspannung beginnt der MOSFET zu schalten? Was ist der Gate-Strom? Aufgabe 2 : Wieviel ist der Verlauf der Leistung bei Aufgabe 1? (Hinweis: ALT + linke Maustaste) Aufgabe 3 : Bestimmen von Rds(on) im voll durchgeschalteten Betrieb. Wieviel Ohm sind es? Passt der Wert zum Datenblatt? (Hinweis: Rds(on)=Vds/Id Aufgabe 4 : Zeichnen des Kennlinienfelds des MOSFET (Hinweis: Sweep Vds von 0-240V, Vgs von 0-20V in 4V Schritten). Warum wurden diese Werte gew\u00e4hlt? Wo befindet sich der lineare Bereich? Wo der S\u00e4ttigungsbereich? Wo der Sperrbereich? Aufgabe 5 : MOSFET Steuerspannung (Vgs) gepulst (100Hz). Wieviel Strom zieht das Gate aufgrund der^ Eingangskapazit\u00e4t Ciss beim Schalten? Kann ein ATmega16 diesen Strom liefern? Aufgabe 6: Linear-Betrieb (Verst\u00e4rker) - tbd","title":"4.2.3 Auswahl eines N-Kanal-MOSFET f\u00fcr Logikpegel"},{"location":"4_switches/#424-anschluss-an-einen-mikrocontroller","text":"Sowohl JFETs als auch MOSFETs haben eine Eingangskapazit\u00e4t (Gate-Kapazit\u00e4t). Diese ist insbesondere beim MOSFET gr\u00f6\u00dfer und resultiert aus der Oxidschicht zwischen dem Gate und dem Kanal. Die hier auftretenden Einschaltstr\u00f6me k\u00f6nnen den IO-Pin eines Mikrocontrollers \u00fcberlasten - dies kann mit der folgenden Schaltung vermieden werden: Der Pull-down Widerstand sorgt dabei f\u00fcr einen definierten Pegel w\u00e4hrend des Starts und Resets des Mikrocontrollers. Anzumerken ist, dass der MOSFET f\u00fcr Logic Level (LL) ausgelegt ist, der schon bei einer Gatespannung von etwa 4.5V voll durchgesteuert sind. Die meisten FET werden mit ca. 10-15V angesteuert, wof\u00fcr wiederum eine eigene Treiberschaltung notwendig ist.","title":"4.2.4 Anschluss an einen Mikrocontroller"},{"location":"4_switches/#43-cmos-inverter","text":"Wird noch erg\u00e4nzt.","title":"4.3 CMOS-Inverter"},{"location":"4_switches/#43-pegelwandler","text":"\" Als Pegelumsetzer oder Pegelwandler (englisch level shifter) bezeichnet man in der Elektronik eine diskrete oder integrierte elektronische Schaltung, welche die Signalpegel \u2013 in der Regel Spannungssignale \u2013 einer Informationsquelle an die Eingangssignalpegel einer Informationssenke anpasst. Pegelumsetzer k\u00f6nnen sowohl in der Analogtechnik als auch in der Digitaltechnik angewendet werden. \" (Wikipedia) Es gibt verschiedenen M\u00f6glichkeiten, einen Pegelwandler umzusetzen. Einiger dieser Methoden sind im folgenden beschrieben:","title":"4.3 Pegelwandler"},{"location":"4_switches/#431-spannungsteiler","text":"Eine einfache und g\u00fcnstige Methode ist ein simpler Spannungsteiler. Dabei berechnet sich die Spannung aus: Bei Verwendung von Widerst\u00e4nden aus der E24-Reihe kann z.B. aus 5V mit einem R1 = 1.8k\u03a9 und R2 = 3.3k\u03a9 eine Ausgangsspannung von 3.3V erzeugt werden. Vorteile Einfach (geeignet f\u00fcr Prototyping) G\u00fcnstig Nachteile Unidirektional Nur von h\u00f6herer zu niedriger Spannung Ungeeignet f\u00fcr hohe Frequenzen","title":"4.3.1 Spannungsteiler"},{"location":"4_switches/#432-diode","text":"\u00c4hnlich einfach ist die Verwendung einer Diode in Verbindung mit einem Widerstand (kann z.B. bei einem Mikrocontroller der interne Pull-up Widerstand am Eingang sein). Liegen an TX 5V an, sperrt die Diode und an RX liegt die Spannung \u00fcber den Pull-up Widerstand an (3V). Ist TX bei 0V, leitet die Diode und an RX liegt 0V + If an (If = Durchlassspannung). [Quelle] Vorteile Einfach (geeignet f\u00fcr Prototyping) G\u00fcnstig Nachteile Unidirektional Nur von h\u00f6herer zu niedriger Spannung Ungeeignet f\u00fcr hohe Frequenzen","title":"4.3.2 Diode"},{"location":"4_switches/#433-mosfet-n-kanal","text":"Mit einem MOSFET ist eine bidirektionale Anpassung des Spannungspegel m\u00f6glich. Die genaue Funktion ist hier erkl\u00e4rt. Vorteile Bidirektional Zuverl\u00e4ssig und schnell Nachteile Komplexer Setzt eine geeignete Auswahl des MOSFET voraus","title":"4.3.3 MOSFET (N-Kanal)"},{"location":"4_switches/#434-logic-level-converters","text":"Es gibt eine Vielzahl an dedizierten Schaltkreisen genau f\u00fcr diesen Zweck. Beispiel TXB0108 (8-Bit, bidirektional) Vorteile Bidirektional Zuverl\u00e4ssig und schnell Nachteile Teurer","title":"4.3.4 Logic Level Converters"},{"location":"4_switches/#435-optokoppler","text":"Optokoppler isolieren zwei Schaltkreise elektrisch voneinander, indem er elektrische Signale mittels Licht \u00fcbertr\u00e4gt. Dies geschieht z.B. durch Verwendung einer LED und eines lichtempfindlichen Bauteils (z.B. Fotodiode). Vorteile Elektrische Isolation Zuverl\u00e4ssig Nachteile Langsamer","title":"4.3.5 Optokoppler"},{"location":"5_adc/","text":"5. ADC - Analog Digital Converter 5.1 Aufgabe / Herausforderung Eine Analoge Spannung soll in einen digitalen Wert umgewandelt werden um vom Mikrocontroller weiter bearbeitet zu werden. Beispiel Voltmeter, Auslesen eines analogen Sensorwertes, ... Die Herausforderung ist dabei, dass... der Messfehler m\u00f6glichst klein sein soll eine entsprechend geeignete Aufl\u00f6sung f\u00fcr die Messaufgabe verwendet wird 5.2 Messverfahren Es gibt verschiedene Verfahren, um analoge Signale in digitale umzuwandeln, z.B. Flash Wandler, Pipeline Wandler, Sigma-Delta Wandler, Slope Wandler und SAR-Wandler. Ein Vergleich der verschiedenen Typen und deren bevorzugte Anwendung findest sich z.B. hier . Beim ATmega16 wird die sukzessive Approximation (SAR-Wandler) verwendet sodass der Fokus auf diesem Wandler ist. Sample & Hold Schaltung H\u00e4lt die zu messende Spannung f\u00fcr die Zeit der Wandlung konstant. Komperator \"Am Ausgang des Komparators steht ein Signal zur Verf\u00fcgung, das anzeigt, welche der beiden Eingangsspannungen h\u00f6her ist. Wenn die Spannung am positiven, nicht-invertierenden Eingang h\u00f6her ist als die Spannung am negativen, invertierenden Eingang, so n\u00e4hert sich die Ausgangsspannung der positiven Versorgungsspannung. Bei umgekehrten Verh\u00e4ltnissen geht die Ausgangsspannung gegen die negative Versorgungsspannung.\" (Wikipedia) 5.3 ATmega16 ADC 5.3.1 Kenngr\u00f6\u00dfen Ein paar Kenngr\u00f6\u00dfen des ADC im ATmega16: max. 10-bit Aufl\u00f6sung (d.h. 1024 Schritte) +/- 2 LSB Absolute Accuracy 13-260us Conversion Time bis zu 15 kSPS bei maximaler Aufl\u00f6sung 8 multiplexed single ended input channels 7 differential input channels 2 differential input channels mit optionaler Verst\u00e4rung von 10x oder 200x 0-Vcc ADC Input Voltage Range Ausw\u00e4hlbare 2.56V ADC Referenz Spannung ... 5.3.2 Blockschaltbild 5.3.3 Referenzspannung Ein ADC vergleicht die Messspannung mit einer Referenzspannung. Deshalb kommt der Stabilit\u00e4t der Referenzspannung eine gro\u00dfe Bedeutung zu! Es kann zwischen unterschiedlichen Referenzspannungen gew\u00e4hlt werden (Register ADMUX Bits REFS1 und REFS0): VAcc Interne 2.56V Referenz Spannung Externe Spannung an Pin AREF Der Wert der Wandlung (bzw. durch Umstellung der Wert der zu messenden Spannung) berechnet sich mit den folgenden Formeln: Parameter Bedeutung n Bitbreite (f\u00fcr ATmega16 -> 10) ADC Wert der Wandlung Vin Spannung am Eingang des ADC Vref Referenzspannung 5.3.4 Prescaling Ein sukzessiver Appriximation Wandler ben\u00f6tigt eine Taktfrequenz zwischen 50kHz und 200kHz um die maximale Aufl\u00f6sung zu erhalten. Sollten weniger als 10 bit Aufl\u00f6sung ausreichen, kann die Taktfrequenz \u00fcber 200 kHz liegen um einer h\u00f6here Abtastrate zu erhalten. Eine normale Wandlung ben\u00f6tigt 13 ADC Taktzyklen. Die erste Wandlung ben\u00f6tigt 25 Taktzyklen um auch die analoge Schaltung im Mikrocontorller zu initialisieren. 5.3.4 Multiplexer Es ist nur ein ADC vorhanden, jedoch 8 ADC-Eing\u00e4nge. Der Multiplexer erm\u00f6glicht die Auswahl des ADC Pins (single ended) bzw. der ADC Pins (differential) sowie GND und einer Bandabstandsreferenz (Bandgap reference, 1.23VDC beim ATmega16). 5.3.5 ADC Register ADMUX - ADC Multiplexer Selection Register ADCSRA - ADC Control and Status Register A SFIOR - Special Function IO Register ADC Data Register - ADCL und ADCH Anmerkung: Grunds\u00e4tzlich wird erst das Low-Byte ausgelesen, danach das High-Byte. Erst wenn auch das High-Byte ausgelesen ist, kann ein neuer Wert in das Register geschrieben wird. Beim GCC gibt es 16-Bit PseudoRegister ( ADC ), bei diesen wird die Zugriffsreihenfolge durch den Compiler automatisch geregelt. Reicht z.B. eine 8-bit Aufl\u00f6sung des zu messenden Signals, kann man z.B. nur ADCL auslesen. 5.3.6 Modi \u00dcber ADC Auto Trigger Source im Register SFIOR k\u00f6nnen verschiedene Modi gew\u00e4hlt werden. Diese werden hier kurz vorgestellt: Single Conversion Hier wird das ADSC (ADC Start Converstion) Bit manuell gesetzt. Das Bit bleibt solange gesetzt bis die Wandlung beendet ist. Ein Wechsel des Eingangkanals \u00fcber den Multiplexer wird erst durchgef\u00fchrt, wenn die Wandlung beendet ist. Free Running mode Der ADC f\u00fchrt kontinuierlich Wandlungen durch. Die erste Wandlung muss manuell gestartet werden (setzen des ADSC Bit in ADCSRA). Analog Comparator Der Analog Comparator vergleicht die Eingangswerte am positiven Pin AIN0 and negativen Pin AIN1. Wenn die Spannung am positiven Pin AIN0 gr\u00f6\u00dfer ist als am negativen Pin AIN1, wird der Analog Comparator Output ACO gesetzt. Verschiedene Interrupt (ohne Analog Comparator) Durch setzen der ADC Trigger Select Bits und einschalten des ADC Auto Trigger Enable wird die Wandlung beim Trigger Signal durchgef\u00fchrt. So k\u00f6nnen z.B. Wandlungen im festen Takt durchgef\u00fchrt werden. Nach der Wandlung muss die Interrupt Flag gel\u00f6scht werden bevor eine neue Wandlung gemacht wird. 5.3.7 Unterschied single ended/differential input Single ended input Beim single ended input wird eine Spannung gegen den gemeinsamen GND (des Mikrocontrollers) gemessen. Typische Anwendungsszenarien sind z.B.: Potentiometer um einen Winkel oder Position zu messen Messung von Lichtst\u00e4rke Messung von Distanzen mittels Infrarot/Ultraschall Messung von Gas- und Luftqualit\u00e4t Vorteile Nachteile Kosteng\u00fcnstig Empfindlich ggbr. St\u00f6rungen auf dem analogen Signalweg Nur ein Input-Pin des uC n\u00f6tig Empfindlich ggbr. Gleichtaktst\u00f6rung Einfach Ggfs. h\u00f6herer Schaltungsaufwand \u00dcbungsbeispiel ADC01 (single ended input) Es soll die \u00fcber ein Potentiometer ver\u00e4nderbare Spannung der MEGACARD eingelesen werden und auf dem Display ausgegeben werden (Achtung: Jumper X14 setzen!). Dabei ist der Spannungsbereich ca. von 0V bis 4.76V (d.h. von 0 bis Vcc, die 4.76V sind ein gemessener Wert). Ablauf: Initialisieren des ADC f\u00fcr ADC5 Setzen Spannungs-Referenz von AVcc Setzen des Prescalers zu 128 Messung starten und Ergebnis abwarten Berechnen der Spannung und Ausgeben des Ergebnisses auf dem Display main.c #include <avr/io.h> #include <util/delay.h> #include \"display.h\" void init (void) { // Grundinitialisierungen ADMUX |= (1<<REFS0) | (1<<MUX2) | (1<<MUX0); // Sets AVcc as reference, and selects ADC5 ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); // Enable ADC and set prescaler to 128 } int read_ADC5(){ ADCSRA |= (1 << ADSC); // Manually start new measurement while (ADCSRA & (1<<ADSC)); // Wait until ADSC bit is cleared -> conversion complete return (ADC); // Return 16-bit value containing both high and low byte } int main (void) { init (); // Aufruf der Grundinitialisierungen display_init(); // Initialisierung der Anzeige int out; float result; out = 0; while (1) { // Hauptschleife out = read_ADC5(); result = (out / 1024.0) * 4.75; display_printf_pos (0, 4, \"Output: %.3f\", result); _delay_ms(500); // delay 500 } return 0; } \u00dcbungsbeispiel ADC02 (Wandlung bei Interrupt) Erg\u00e4nzen Sie das obige Beispiel so, dass die Messung jeweils exakt alle zwei Sekunden durchgef\u00fchrt wird. Differential input Hat jetzt ein Signal z.B. einen Wertebereich zwischen 2 und 3 V so w\u00fcrde beim single ended input Aufl\u00f6sung verloren gehen (weil die 10bit Aufl\u00f6sung f\u00fcr den kompletten Bereich von 0-3 V angewendet werden). Vorteile Nachteile Unterdr\u00fcckt Rauschen im Signal Ben\u00f6tigt zwei Pins pro Sensor Auch f\u00fcr sehr kleine Signale geeignet Komplexer Verwendet man hier nun einen differential input gem\u00e4\u00df unten dargestellter Schaltung, kann f\u00fcr das gemessene Signal (hier +/- 0.5V) die volle Aufl\u00f6sung verwendet werden. Weiterf\u00fchrende Dokumentation zu den beiden Varianten findet sich z.B. hier. 5.3.8 Genauigkeit und Fehler Steht im Datenblatt :) 5.3.9 Elektrische Eigenschaften (ADC) Zu beachtende elektrische Grenzen finden sich in Tabelle 122 (ADC Characteristics) des ATmega16 Datenblatt. Eine Auswahl ist hier wiedergegeben: Symbol Parameter Min Typ Max Units AVcc Analog Supply Voltage Vcc-0.3 (2.7V) Vcc+0.3 (5.5) V Vref Reference Voltage - Single Ended 2.0 AVcc V Vref Reference Voltage - Differential 2.0 AVcc - 0.2 V Vin Input Voltage - Single Ended GND Vref V Vin Input Voltage - Differential 0 Vref V RAin Analog Input Voltage 100 MOhm","title":"5. ADC - Analog Digital Converter"},{"location":"5_adc/#5-adc-analog-digital-converter","text":"","title":"5. ADC - Analog Digital Converter"},{"location":"5_adc/#51-aufgabe-herausforderung","text":"Eine Analoge Spannung soll in einen digitalen Wert umgewandelt werden um vom Mikrocontroller weiter bearbeitet zu werden. Beispiel Voltmeter, Auslesen eines analogen Sensorwertes, ... Die Herausforderung ist dabei, dass... der Messfehler m\u00f6glichst klein sein soll eine entsprechend geeignete Aufl\u00f6sung f\u00fcr die Messaufgabe verwendet wird","title":"5.1 Aufgabe / Herausforderung"},{"location":"5_adc/#52-messverfahren","text":"Es gibt verschiedene Verfahren, um analoge Signale in digitale umzuwandeln, z.B. Flash Wandler, Pipeline Wandler, Sigma-Delta Wandler, Slope Wandler und SAR-Wandler. Ein Vergleich der verschiedenen Typen und deren bevorzugte Anwendung findest sich z.B. hier . Beim ATmega16 wird die sukzessive Approximation (SAR-Wandler) verwendet sodass der Fokus auf diesem Wandler ist. Sample & Hold Schaltung H\u00e4lt die zu messende Spannung f\u00fcr die Zeit der Wandlung konstant. Komperator \"Am Ausgang des Komparators steht ein Signal zur Verf\u00fcgung, das anzeigt, welche der beiden Eingangsspannungen h\u00f6her ist. Wenn die Spannung am positiven, nicht-invertierenden Eingang h\u00f6her ist als die Spannung am negativen, invertierenden Eingang, so n\u00e4hert sich die Ausgangsspannung der positiven Versorgungsspannung. Bei umgekehrten Verh\u00e4ltnissen geht die Ausgangsspannung gegen die negative Versorgungsspannung.\" (Wikipedia)","title":"5.2 Messverfahren"},{"location":"5_adc/#53-atmega16-adc","text":"","title":"5.3 ATmega16 ADC"},{"location":"5_adc/#531-kenngroen","text":"Ein paar Kenngr\u00f6\u00dfen des ADC im ATmega16: max. 10-bit Aufl\u00f6sung (d.h. 1024 Schritte) +/- 2 LSB Absolute Accuracy 13-260us Conversion Time bis zu 15 kSPS bei maximaler Aufl\u00f6sung 8 multiplexed single ended input channels 7 differential input channels 2 differential input channels mit optionaler Verst\u00e4rung von 10x oder 200x 0-Vcc ADC Input Voltage Range Ausw\u00e4hlbare 2.56V ADC Referenz Spannung ...","title":"5.3.1 Kenngr\u00f6\u00dfen"},{"location":"5_adc/#532-blockschaltbild","text":"","title":"5.3.2 Blockschaltbild"},{"location":"5_adc/#533-referenzspannung","text":"Ein ADC vergleicht die Messspannung mit einer Referenzspannung. Deshalb kommt der Stabilit\u00e4t der Referenzspannung eine gro\u00dfe Bedeutung zu! Es kann zwischen unterschiedlichen Referenzspannungen gew\u00e4hlt werden (Register ADMUX Bits REFS1 und REFS0): VAcc Interne 2.56V Referenz Spannung Externe Spannung an Pin AREF Der Wert der Wandlung (bzw. durch Umstellung der Wert der zu messenden Spannung) berechnet sich mit den folgenden Formeln: Parameter Bedeutung n Bitbreite (f\u00fcr ATmega16 -> 10) ADC Wert der Wandlung Vin Spannung am Eingang des ADC Vref Referenzspannung","title":"5.3.3 Referenzspannung"},{"location":"5_adc/#534-prescaling","text":"Ein sukzessiver Appriximation Wandler ben\u00f6tigt eine Taktfrequenz zwischen 50kHz und 200kHz um die maximale Aufl\u00f6sung zu erhalten. Sollten weniger als 10 bit Aufl\u00f6sung ausreichen, kann die Taktfrequenz \u00fcber 200 kHz liegen um einer h\u00f6here Abtastrate zu erhalten. Eine normale Wandlung ben\u00f6tigt 13 ADC Taktzyklen. Die erste Wandlung ben\u00f6tigt 25 Taktzyklen um auch die analoge Schaltung im Mikrocontorller zu initialisieren.","title":"5.3.4 Prescaling"},{"location":"5_adc/#534-multiplexer","text":"Es ist nur ein ADC vorhanden, jedoch 8 ADC-Eing\u00e4nge. Der Multiplexer erm\u00f6glicht die Auswahl des ADC Pins (single ended) bzw. der ADC Pins (differential) sowie GND und einer Bandabstandsreferenz (Bandgap reference, 1.23VDC beim ATmega16).","title":"5.3.4 Multiplexer"},{"location":"5_adc/#535-adc-register","text":"ADMUX - ADC Multiplexer Selection Register ADCSRA - ADC Control and Status Register A SFIOR - Special Function IO Register ADC Data Register - ADCL und ADCH Anmerkung: Grunds\u00e4tzlich wird erst das Low-Byte ausgelesen, danach das High-Byte. Erst wenn auch das High-Byte ausgelesen ist, kann ein neuer Wert in das Register geschrieben wird. Beim GCC gibt es 16-Bit PseudoRegister ( ADC ), bei diesen wird die Zugriffsreihenfolge durch den Compiler automatisch geregelt. Reicht z.B. eine 8-bit Aufl\u00f6sung des zu messenden Signals, kann man z.B. nur ADCL auslesen.","title":"5.3.5 ADC Register"},{"location":"5_adc/#536-modi","text":"\u00dcber ADC Auto Trigger Source im Register SFIOR k\u00f6nnen verschiedene Modi gew\u00e4hlt werden. Diese werden hier kurz vorgestellt: Single Conversion Hier wird das ADSC (ADC Start Converstion) Bit manuell gesetzt. Das Bit bleibt solange gesetzt bis die Wandlung beendet ist. Ein Wechsel des Eingangkanals \u00fcber den Multiplexer wird erst durchgef\u00fchrt, wenn die Wandlung beendet ist. Free Running mode Der ADC f\u00fchrt kontinuierlich Wandlungen durch. Die erste Wandlung muss manuell gestartet werden (setzen des ADSC Bit in ADCSRA). Analog Comparator Der Analog Comparator vergleicht die Eingangswerte am positiven Pin AIN0 and negativen Pin AIN1. Wenn die Spannung am positiven Pin AIN0 gr\u00f6\u00dfer ist als am negativen Pin AIN1, wird der Analog Comparator Output ACO gesetzt. Verschiedene Interrupt (ohne Analog Comparator) Durch setzen der ADC Trigger Select Bits und einschalten des ADC Auto Trigger Enable wird die Wandlung beim Trigger Signal durchgef\u00fchrt. So k\u00f6nnen z.B. Wandlungen im festen Takt durchgef\u00fchrt werden. Nach der Wandlung muss die Interrupt Flag gel\u00f6scht werden bevor eine neue Wandlung gemacht wird.","title":"5.3.6 Modi"},{"location":"5_adc/#537-unterschied-single-endeddifferential-input","text":"Single ended input Beim single ended input wird eine Spannung gegen den gemeinsamen GND (des Mikrocontrollers) gemessen. Typische Anwendungsszenarien sind z.B.: Potentiometer um einen Winkel oder Position zu messen Messung von Lichtst\u00e4rke Messung von Distanzen mittels Infrarot/Ultraschall Messung von Gas- und Luftqualit\u00e4t Vorteile Nachteile Kosteng\u00fcnstig Empfindlich ggbr. St\u00f6rungen auf dem analogen Signalweg Nur ein Input-Pin des uC n\u00f6tig Empfindlich ggbr. Gleichtaktst\u00f6rung Einfach Ggfs. h\u00f6herer Schaltungsaufwand \u00dcbungsbeispiel ADC01 (single ended input) Es soll die \u00fcber ein Potentiometer ver\u00e4nderbare Spannung der MEGACARD eingelesen werden und auf dem Display ausgegeben werden (Achtung: Jumper X14 setzen!). Dabei ist der Spannungsbereich ca. von 0V bis 4.76V (d.h. von 0 bis Vcc, die 4.76V sind ein gemessener Wert). Ablauf: Initialisieren des ADC f\u00fcr ADC5 Setzen Spannungs-Referenz von AVcc Setzen des Prescalers zu 128 Messung starten und Ergebnis abwarten Berechnen der Spannung und Ausgeben des Ergebnisses auf dem Display main.c #include <avr/io.h> #include <util/delay.h> #include \"display.h\" void init (void) { // Grundinitialisierungen ADMUX |= (1<<REFS0) | (1<<MUX2) | (1<<MUX0); // Sets AVcc as reference, and selects ADC5 ADCSRA |= (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0); // Enable ADC and set prescaler to 128 } int read_ADC5(){ ADCSRA |= (1 << ADSC); // Manually start new measurement while (ADCSRA & (1<<ADSC)); // Wait until ADSC bit is cleared -> conversion complete return (ADC); // Return 16-bit value containing both high and low byte } int main (void) { init (); // Aufruf der Grundinitialisierungen display_init(); // Initialisierung der Anzeige int out; float result; out = 0; while (1) { // Hauptschleife out = read_ADC5(); result = (out / 1024.0) * 4.75; display_printf_pos (0, 4, \"Output: %.3f\", result); _delay_ms(500); // delay 500 } return 0; } \u00dcbungsbeispiel ADC02 (Wandlung bei Interrupt) Erg\u00e4nzen Sie das obige Beispiel so, dass die Messung jeweils exakt alle zwei Sekunden durchgef\u00fchrt wird. Differential input Hat jetzt ein Signal z.B. einen Wertebereich zwischen 2 und 3 V so w\u00fcrde beim single ended input Aufl\u00f6sung verloren gehen (weil die 10bit Aufl\u00f6sung f\u00fcr den kompletten Bereich von 0-3 V angewendet werden). Vorteile Nachteile Unterdr\u00fcckt Rauschen im Signal Ben\u00f6tigt zwei Pins pro Sensor Auch f\u00fcr sehr kleine Signale geeignet Komplexer Verwendet man hier nun einen differential input gem\u00e4\u00df unten dargestellter Schaltung, kann f\u00fcr das gemessene Signal (hier +/- 0.5V) die volle Aufl\u00f6sung verwendet werden. Weiterf\u00fchrende Dokumentation zu den beiden Varianten findet sich z.B. hier.","title":"5.3.7 Unterschied single ended/differential input"},{"location":"5_adc/#538-genauigkeit-und-fehler","text":"Steht im Datenblatt :)","title":"5.3.8 Genauigkeit und Fehler"},{"location":"5_adc/#539-elektrische-eigenschaften-adc","text":"Zu beachtende elektrische Grenzen finden sich in Tabelle 122 (ADC Characteristics) des ATmega16 Datenblatt. Eine Auswahl ist hier wiedergegeben: Symbol Parameter Min Typ Max Units AVcc Analog Supply Voltage Vcc-0.3 (2.7V) Vcc+0.3 (5.5) V Vref Reference Voltage - Single Ended 2.0 AVcc V Vref Reference Voltage - Differential 2.0 AVcc - 0.2 V Vin Input Voltage - Single Ended GND Vref V Vin Input Voltage - Differential 0 Vref V RAin Analog Input Voltage 100 MOhm","title":"5.3.9 Elektrische Eigenschaften (ADC)"},{"location":"6_dac/","text":"6. DAC - Digital Analog Converter 6.1 Aufgabe / Herausforderung Manche Anwendungen erfordern, dass aus einem digitalen Signal eine analoge Spannung erzeugt wird, wie etwa die Ausgabe eines Musiksignals auf einem Kopfh\u00f6rer. F\u00fcr diese Aufgabe gibt es dedizierte IC's. Die AVR-Mikrocontorller Serie hat keinen integrierten DAC. Hier kann ein einfaches RC-Glied (Tiefpass) verwendet werden, welches mit einem PWM Signal gespeist wird. 6.2 Beispiel RC-Glied MEGACARD v6 Auf der MEGACARD v6 befindet sich ein Tiefpass, welcher am Pin OC0/PB3 angeschlossen (Timer0): \u00dcber eine R\u00fcckf\u00fchrung zu ADC7/PA7 kann das \u00fcber ein PWM erzeugte Analog-Signal wieder eingelesen werden. 6.3 \u00dcberlegungen zur Dimensionierung Der Duty Cycle (D) kann zwischen 0% und 100% variiert werden. Ein D von 0% erzeugt eine Ausgangsspannung von 0VDC. Ein D von 100% erzeugt eine Ausgangsspannung von Vcc. Ein D dazwischen erzeugt ein Analogsignal von x% von Vcc. Beispiel Duty Cycle 50% / fPWM = 50kHz Niedrige PWM-Frequenzen erh\u00f6hen den Ripple am Ausgang des Filters deutlich. F\u00fcr Wechselsignale ist zudem die D\u00e4mpfung des RC-Glied (Tiefpass) zu beachten, da h\u00f6here Frequenzen entsprechend abgeschw\u00e4cht werden. Zu beachten ist weiters, dass es eine gewisse Zeit ben\u00f6tigt bis die korrekte Spannung am Kondensator anliegt. Zur Erzeugung des PWM-Signals bietet sich der Fast-PWM Mode an. Die LTspice Datei kann hier heruntergeladen werden. Weiterf\u00fchrende Informationen finden Sie z.B. in diesem Microchip Technical Brief.","title":"6. DAC - Digital Analog Converter"},{"location":"6_dac/#6-dac-digital-analog-converter","text":"","title":"6. DAC - Digital Analog Converter"},{"location":"6_dac/#61-aufgabe-herausforderung","text":"Manche Anwendungen erfordern, dass aus einem digitalen Signal eine analoge Spannung erzeugt wird, wie etwa die Ausgabe eines Musiksignals auf einem Kopfh\u00f6rer. F\u00fcr diese Aufgabe gibt es dedizierte IC's. Die AVR-Mikrocontorller Serie hat keinen integrierten DAC. Hier kann ein einfaches RC-Glied (Tiefpass) verwendet werden, welches mit einem PWM Signal gespeist wird.","title":"6.1 Aufgabe / Herausforderung"},{"location":"6_dac/#62-beispiel-rc-glied-megacard-v6","text":"Auf der MEGACARD v6 befindet sich ein Tiefpass, welcher am Pin OC0/PB3 angeschlossen (Timer0): \u00dcber eine R\u00fcckf\u00fchrung zu ADC7/PA7 kann das \u00fcber ein PWM erzeugte Analog-Signal wieder eingelesen werden.","title":"6.2 Beispiel RC-Glied MEGACARD v6"},{"location":"6_dac/#63-uberlegungen-zur-dimensionierung","text":"Der Duty Cycle (D) kann zwischen 0% und 100% variiert werden. Ein D von 0% erzeugt eine Ausgangsspannung von 0VDC. Ein D von 100% erzeugt eine Ausgangsspannung von Vcc. Ein D dazwischen erzeugt ein Analogsignal von x% von Vcc. Beispiel Duty Cycle 50% / fPWM = 50kHz Niedrige PWM-Frequenzen erh\u00f6hen den Ripple am Ausgang des Filters deutlich. F\u00fcr Wechselsignale ist zudem die D\u00e4mpfung des RC-Glied (Tiefpass) zu beachten, da h\u00f6here Frequenzen entsprechend abgeschw\u00e4cht werden. Zu beachten ist weiters, dass es eine gewisse Zeit ben\u00f6tigt bis die korrekte Spannung am Kondensator anliegt. Zur Erzeugung des PWM-Signals bietet sich der Fast-PWM Mode an. Die LTspice Datei kann hier heruntergeladen werden. Weiterf\u00fchrende Informationen finden Sie z.B. in diesem Microchip Technical Brief.","title":"6.3 \u00dcberlegungen zur Dimensionierung"},{"location":"7_uart/","text":"7. Schnittstellen 7.1 UART 7.1.1 Allgemeines U niversal A synchronous R eceiver T ransmitter Die UART-Schnittstelle beschreibt ein serielles Kommunikations-Protokoll welches von vielen Mikrocontrollern unterst\u00fctzt wird. 7.1.2 Typische Anwendungsgebiete Debugging Steuerung und Datenkommunikation 7.1.3 Protokoll 7.1.4 Baudrate 7.1.5 Elektrische 7.2 I2C Noch nicht bearbeitet. 7.3 SPI Noch nicht bearbeitet.","title":"7. Schnittstellen"},{"location":"7_uart/#7-schnittstellen","text":"","title":"7. Schnittstellen"},{"location":"7_uart/#71-uart","text":"","title":"7.1 UART"},{"location":"7_uart/#711-allgemeines","text":"U niversal A synchronous R eceiver T ransmitter Die UART-Schnittstelle beschreibt ein serielles Kommunikations-Protokoll welches von vielen Mikrocontrollern unterst\u00fctzt wird.","title":"7.1.1 Allgemeines"},{"location":"7_uart/#712-typische-anwendungsgebiete","text":"Debugging Steuerung und Datenkommunikation","title":"7.1.2 Typische Anwendungsgebiete"},{"location":"7_uart/#713-protokoll","text":"","title":"7.1.3 Protokoll"},{"location":"7_uart/#714-baudrate","text":"","title":"7.1.4 Baudrate"},{"location":"7_uart/#715-elektrische","text":"","title":"7.1.5 Elektrische"},{"location":"7_uart/#72-i2c","text":"Noch nicht bearbeitet.","title":"7.2 I2C"},{"location":"7_uart/#73-spi","text":"Noch nicht bearbeitet.","title":"7.3 SPI"},{"location":"A_ressources/","text":"A. Ressourcen A.1 Datenblatt ATmega16 Datenblatt Rev. 2466T\u2013AVR\u201307/10 Pinout ATmega16 A.2 MEGACARD v6.11 Schaltplan Best\u00fcckungsplan","title":"A. Ressourcen"},{"location":"A_ressources/#a-ressourcen","text":"","title":"A. Ressourcen"},{"location":"A_ressources/#a1-datenblatt-atmega16","text":"Datenblatt Rev. 2466T\u2013AVR\u201307/10 Pinout ATmega16","title":"A.1 Datenblatt ATmega16"},{"location":"A_ressources/#a2-megacard-v611","text":"Schaltplan Best\u00fcckungsplan","title":"A.2 MEGACARD v6.11"}]}